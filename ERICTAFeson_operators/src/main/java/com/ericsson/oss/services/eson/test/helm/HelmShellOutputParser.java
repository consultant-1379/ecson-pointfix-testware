/*------------------------------------------------------------------------------
 *******************************************************************************
 * COPYRIGHT Ericsson 2018
 *
 * The copyright to the computer program(s) herein is the property of
 * Ericsson Inc. The programs may be used and/or copied only with written
 * permission from Ericsson Inc. or in accordance with the terms and
 * conditions stipulated in the agreement/contract under which the
 * program(s) have been supplied.
 *******************************************************************************
 *----------------------------------------------------------------------------*/
package com.ericsson.oss.services.eson.test.helm;

import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ericsson.commonlibrary.utilities.Utilities;

/**
 * <b>HelmShellOutputParser</b> is responsible for parsing the output as generated by helm command.
 */

public final class HelmShellOutputParser {

    private static final Logger LOGGER = LoggerFactory.getLogger(HelmShellOutputParser.class);

    public static final String KEY_HELM_REVISION = "REVISION";
    public static final String KEY_HELM_UPDATED = "UPDATED";
    public static final String KEY_HELM_STATUS = "STATUS";
    public static final String KEY_HELM_CHART = "CHART";
    public static final String KEY_HELM_DESCRIPTION = "DESCRIPTION";
    private static final String[] ELIGIBLE_HELM_RELEASE_STATUSES_FOR_ROLLBACK = new String[] {
            HelmReleaseStatus.DEPLOYED, HelmReleaseStatus.SUPERSEDED };
    public static final int DEFAULT_RELEASE_LEVEL = 1;

    private static final String NEW_LINE = System.lineSeparator();
    private static final String NEW_TAB = "\t";
    private static final String ERROR_RESPONSE_PREFIX = "Error:";
    private static final String ERR_MSG_NO_REV_FOUND = " No Revision found ";
    private static final String ERR_MSG_NO_CONSOLE_OUTPUT_FOUND = "No data found to parse ";

    private HelmShellOutputParser() {
    }

    public static Map<String, String> findCurrentHelmRelease(final String data) throws HelmException {
        final Deque<Map<String, String>> parsedData = parseHelmHistoryOutput(data);
        if (parsedData.isEmpty()) {
            throw new HelmException(ERR_MSG_NO_REV_FOUND);
        }
        LOGGER.info("Current State : {}", parsedData.getLast());

        return parsedData.getLast();
    }

    /**
     * Finds the eligible details including revision number of the deployed artifact based on release level.
     *
     * @param data
     * @param releaseLevel
     * @return
     * @throws HelmException
     */
    public static Map<String, String> findEligibleReleaseForRollback(final String data, final int releaseLevel)
            throws HelmException {
        final Deque<Map<String, String>> parsedData = parseHelmHistoryOutput(data);

        if (parsedData.isEmpty()) {
            throw new HelmException(ERR_MSG_NO_REV_FOUND);
        }

        LOGGER.info("Current State : {} ", parsedData.getLast());

        // Ignoring last status as it should be the current state of upgrade
        // Possible status : FAILED or DEPLOYED
        parsedData.pollLast();

        Map<String, String> eligibleRevision = null;
        int skipReleaseCount = 1;
        while (!parsedData.isEmpty()) {
            if (ArrayUtils.contains(HelmShellOutputParser.ELIGIBLE_HELM_RELEASE_STATUSES_FOR_ROLLBACK,
                    parsedData.getLast().get(HelmShellOutputParser.KEY_HELM_STATUS))) {
                if (skipReleaseCount == releaseLevel) {
                    eligibleRevision = parsedData.getLast();
                    break;
                } else {
                    parsedData.pollLast();
                    skipReleaseCount++;
                }
            } else {
                parsedData.pollLast();
            }
        }
        if (eligibleRevision == null) {
            throw new HelmException(ERR_MSG_NO_REV_FOUND);
        }
        LOGGER.info("Rolling back to  : {}", eligibleRevision);

        return eligibleRevision;
    }

    private static Deque<Map<String, String>> parseHelmHistoryOutput(final String data) throws HelmException {

        if (StringUtils.isBlank(data)) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND);
        }

        if (StringUtils.startsWith(data, ERROR_RESPONSE_PREFIX)) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND);
        }
        final Deque<Map<String, String>> parsedData = new ArrayDeque<>();

        final String[] lines = StringUtils.split(data, NEW_LINE);

        if (lines == null) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND);
        }

        final String[] headerToken = StringUtils.split(lines[0], NEW_TAB);
        final String[] dataLines = ArrayUtils.remove(lines, 0);

        for (final String dataLine : dataLines) {
            final Map<String, String> map = new HashMap<>();
            final String[] dataTokens = StringUtils.split(dataLine, NEW_TAB);
            for (int i = 0; i < headerToken.length; i++) {
                map.put(StringUtils.strip(headerToken[i]), StringUtils.strip(dataTokens[i]));
            }
            parsedData.add(map);
        }

        return parsedData;
    }

    /**
     * Parses helm list --all output.<br>
     * Saves all release info to list of HelmRelease objects.
     *
     * @param helmListOutput
     *            command output to parse.
     * @return list of HelmRelease objects.
     * @throws HelmException
     *             in case of an error while parsing.
     */
    public static List<HelmRelease> parseHelmReleases(final String helmListOutput) throws HelmException {

        if (StringUtils.isBlank(helmListOutput)) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND + " helm list output");
        }

        if (StringUtils.startsWith(helmListOutput, ERROR_RESPONSE_PREFIX)) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND + " helm list output");
        }

        final List<String> lines = Utilities.string().splitByNewLine(helmListOutput);

        if (Utilities.list().isNullOrEmpty(lines)) {
            throw new HelmException(ERR_MSG_NO_CONSOLE_OUTPUT_FOUND + " helm list output");
        }

        // Check if all columns are there
        if (Utilities.string().splitByRegex(Utilities.list().getFirstElement(lines), NEW_TAB).size() < 6) {
            throw new HelmException("helm list --all output is not as expected!");
        }

        final GetColumnNumber getColumnNumber = new GetColumnNumber(lines).invoke();
        final int nameColumn = getColumnNumber.getNameColumn();
        final int namespaceColumn = getColumnNumber.getNamespaceColumn();
        final int revisionColumn = getColumnNumber.getRevisionColumn();
        final int updatedColumn = getColumnNumber.getUpdatedColumn();
        final int statusColumn = getColumnNumber.getStatusColumn();
        final int chartColumn = getColumnNumber.getChartColumn();
        // Removes header from printout
        final List<String> dataLines = lines.subList(1, lines.size());
        final List<HelmRelease> helmReleases = new ArrayList<>();

        for (final String dataLine : dataLines) {
            final List<String> lineTokens = Utilities.string().splitByRegex(dataLine, NEW_TAB);
            if (lineTokens.size() < 6) {
                LOGGER.error("Could not parse properly line: {}", dataLine);
                continue;
            }


            final HelmRelease helmRelease = new HelmRelease();


            helmRelease.setReleaseName(lineTokens.get(nameColumn).trim());
            helmRelease.setRevision(Utilities.numeric().parseInteger(lineTokens.get(revisionColumn).trim()));
            helmRelease.setUpdated(Utilities.dateTime().parseDate(new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy"),
                    lineTokens.get(updatedColumn).trim()));
            helmRelease.setStatus(new HelmReleaseStatus(lineTokens.get(statusColumn).trim().toUpperCase()));
            helmRelease.setChart(lineTokens.get(chartColumn).trim());
            helmRelease.setNamespace(lineTokens.get(namespaceColumn).trim());
            helmReleases.add(helmRelease);
        }

        return helmReleases;

    }

    /**
     * Parse helm server side version from "helm version -s --short"
     *
     * @param helm server side version result
     * @return helm server side version. e.g. "2.7.2"
     */
    public static String parseHelmServerVersion(final String helmServerVerResult) {
        return helmServerVerResult.toLowerCase().replaceAll("^server: +v", "").replaceAll("\\+.*$", "").trim();
    }

    /**
     * Parses helm client side version from "helm version -c --short".
     *
     * @param helm client side version command output.
     * @return helm client side version. e.g. "2.7.2".
     */
    public static String parseHelmClientVersion(final String helmServerVerResult) {
        return helmServerVerResult.toLowerCase().replaceAll("^client: +v", "").replaceAll("\\+.*$", "").trim();
    }

    private static class GetColumnNumber {
        private final List<String> lines;
        private int nameColumn;
        private int namespaceColumn;
        private int revisionColumn;
        private int updatedColumn;
        private int statusColumn;
        private int chartColumn;

        public GetColumnNumber(final List<String> lines) {
            this.lines = lines;
        }

        public int getNameColumn() {
            return nameColumn;
        }

        public int getNamespaceColumn() {
            return namespaceColumn;
        }

        public int getRevisionColumn() {
            return revisionColumn;
        }

        public int getUpdatedColumn() {
            return updatedColumn;
        }

        public int getStatusColumn() {
            return statusColumn;
        }

        public int getChartColumn() {
            return chartColumn;
        }

        public GetColumnNumber invoke() {
            nameColumn = 0;
            namespaceColumn = 0;
            revisionColumn = 0;
            updatedColumn = 0;
            statusColumn = 0;
            chartColumn = 0;

            final List<String> headerTokens =  Utilities.string().splitByRegex(String.valueOf(lines), NEW_TAB);
            for (int i = 0; i < headerTokens.size(); i++) {
                if (headerTokens.get(i).contains("NAME"))
                {
                    nameColumn = i;
                }
                else if(headerTokens.get(i).contains("NAMESPACE")){
                    namespaceColumn = i;
                }
                else if(headerTokens.get(i).contains("REVISION")){
                    revisionColumn = i;
                }
                else if(headerTokens.get(i).contains("UPDATED")){
                    updatedColumn = i;
                }
                else if(headerTokens.get(i).contains("STATUS")){
                    statusColumn = i;
                }
                else if(headerTokens.get(i).contains("CHART")){
                    chartColumn = i;
                }
            }
            return this;
        }
    }
}